## Функциональные требования
### 1. Отслеживание кликов.
Сервис должен собирать данные о кликах пользователя по различным элементам интерфейса, таким как фильмы, трейлеры, 
категории и другие ключевые элементы сайта.

### 2. Отслеживание просмотров страниц.
Система должна отслеживать, какие страницы (например, страницы фильмов, категорий, акционных предложений) пользователи 
просматривают и сколько времени проводят на них.

### 3. Отслеживание кастомных событий.
Сервис должен иметь возможность отслеживания следующих кастомных событий:

- Смена качества видео. Запись каждого изменения качества просматриваемого видео (например, переключение с 720p на 1080p).
- Просмотр видео до конца. Фиксация каждого просмотра фильма или шоу до конца. Это может помочь анализировать, насколько контент удерживает внимание пользователя.
- Использование фильтров поиска. Запись использования различных фильтров при поиске фильмов (например, по жанру, рейтингу, актерам).

## Нефункциональные требования
### 1. Ежедневно активные пользователи (DAU).
1300 пользователей.
### 2. Ежемесячно активные пользователи (MAU).
8000 пользователей.
### 3. Производительность (RPS).
Обработка 660 событий в секунду.
### 4. Надёжность.
SLA uptime ≥ 99,9 %.
### 5. Скорость отклика
Латентность приёма события (API) < 100 мс.
### 6. Целостность и качество данных
- Валидация схемы входящих событий.
- Мониторинг пропусков и дубликатов.
### 7. Расширяемость и поддерживаемость.
- Лёгкое добавление новых типов событий без кардинальных изменений архитектуры.
- Документация API.
### 8. Формат сообщений.
- Поддержка JSON формата.
- Средний размер сообщения 400 байт на событие.

## Логика работы с событиями.
1. **Flask** принимает JSON:

    - Отслеживание кликов.

          {
             "event": "element_click",
             "token": "srt | null",
             "data": {
                 "element_type": "str" (movie, category, trailer и т.д.),
                 "page_type": "str" (movie, category, promotion и т.д.),
             }
          }

    - Отслеживание просмотров страниц.
    
      Для отслеживания времени проводимого пользователем на страницах, клиент должен генерировать ***"page_view_id"*** и 
      сохранять до момента ухода с просматриваемой страницы, для того что-бы можно было явно отслеживать связанные 
      сообщения о событиях данного типа.

          {
             "event": "str" (page_view_start или page_view_end),
             "token": "srt | null",
             "data": {
                 "page_view_id": "UUID",
                 "page_type": "str" (movie, category, promotion и т.д.),
             }
          }

   - Смена качества видео.
   
         {
             "event": "quality_change",
             "token": "srt | null",
             "data": {
                 "video_id": "str",
                 "old_quality": "int",
                 "new_quality": "int",
             }
         }

   - Просмотр видео до конца.
   
         {
             "event": "video_complete",
             "token": "srt | null",
             "data": {
                 "video_id": "str",
                 "duration_total": "bool",
             }
         }

   - Использование фильтров поиска.
   
         {
             "event": "search_filter",
             "token": "srt | null",
             "data": {
                 "search_query": "str",
                 "filters": "str",
             }
         }

2. Для ненулевого значения ***"token"*** производится проверка токена через **auth_service** с учётом кеша в Redis.
В случаи недоступности сервиса **auth_service** производится локальная проверка токена без учёта его времени жизни.
По результатам проверки, данные обогащаются ключом ***"user_id"*** с ID пользователя или значением *"anonymous"* если 
токен отсутствовал. А ***"token"*** удаляется из сообщения.

3. Данные обогащаются временной меткой ***"timestamp"*** и публикуются в **Kafka** с ключом, взятым из ***"event"***.

4. ETL-сервис (по расписанию) читает новые сообщения из **Kafka**.
    
    Для каждого события со значение ***"event"*** равным ***"page_view_start"*** или ***"page_view_end"***:
        
    - Производим поиск пары, для события просмотра страницы, по ключам ***"user_id"*** и ***"page_view_id"***;
    -  Для оставшихся сообщений пытаемся найти пару в Redis под ключом ***"pv:{page_view_id}.{user_id}"***
    (если пара находится в Redis, то после получения данных эта запись удаляется);
    - Сообщения без пары отправляем в Redis под ключом ***"pv:{page_view_id}.{user_id}"***
    (Для того, что-бы не терять данных аналитики для тех случаев, когда от клиента не приходит 
    сообщения об окончании присмотра страницы, в Redis будут добавляться записи о начале просмотра страницы два 
    в разные *db*. В первой *db* записи будут храниться с временем жизни 12 часов, а в другой без этой метки. 
    Сообщения об окончании просмотра будут добавляться только в первую *db* и временем жизни немного меньше чем 
    временные промежутки между двумя запусками данного ETL процесса. Это сделано для случаев, когда из **Kafka**
    сначала приходит конечный фрагмент, а начало попадает в следующий ETL процесс.);
    - Для сообщений с парой, формируется новое сообщение, содержащее общую информацию, вычисленное время 
    нахождения пользователя на данной странице и флагом того, что эти данные парные:

          {
              "event": "page_view",
              "user_id": "UUID",
              "timestamp": "DateTime",
              "data": {
                  "duration_seconds": "TimeDelta",
                  "page_type": "str" (movie, category, promotion и т.д.),
                  "paired": "True"
              }
          }

    - Получаем из Redis все ключи от первой и второй *db. Ключи из второй *db*, которых нет в первой, считаем 
    не имеющих возможности дождаться пары и формируем для них сообщения с неполными данными:
            
          {
              "event": "page_view",
              "user_id": "UUID",
              "timestamp": "DateTime",
              "data": {
                  "duration_seconds": "null",
                  "page_type": "str" (movie, category, promotion и т.д.),
                  "paired": "False"
              }
          }

5. Все сформированные и валидные сообщения **ETL** отправляет в соответствующую значению ***"event"*** таблицу 
**ClickHouse**.