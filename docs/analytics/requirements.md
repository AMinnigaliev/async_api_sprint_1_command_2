## Функциональные требования
### 1. Обработка событий просмотра страницы.
Система должна предоставлять единый интерфейс приёма событий.

### 2. Валидация входных данных.
При поступлении события система должна проверять его структуру и наличие обязательных полей.

### 3. Определение пользователя.
При наличии пользовательского токена, система обязана извлечь из него идентификатор пользователя с помощью внешнего 
сервиса аутентификации.

### 4. Обогащение события.
Каждое принятое событие должно быть дополнено текущей временной меткой, указывающей точный момент его получения 
системой.

### 5. Передача событий в хранилище.
Принятые и обогащённые события должны быть переданы в последующую подсистему хранения и обработки, обеспечивающую 
возможность дальнейшего анализа пользовательского поведения.

### 6. Сопоставление событий.
Система аналитической обработки должна иметь возможность сопоставлять связанные события по уникальному идентификатору 
сессии.

## Нефункциональные требования
### 1. Ежедневно активные пользователи (DAU).
1300 пользователей.
### 2. Ежемесячно активные пользователи (MAU).
8000 пользователей.
### 3. Производительность (RPS).
Обработка 660 событий в секунду.
### 4. Надёжность.
SLA uptime ≥ 99,9 %.
### 5. Скорость отклика
Латентность приёма события (API) < 100 мс.
### 6. Целостность и качество данных
- Валидация схемы входящих событий.
- Мониторинг пропусков и дубликатов.
### 7. Расширяемость и поддерживаемость.
- Лёгкое добавление новых типов событий без кардинальных изменений архитектуры.
- Документация API.
### 8. Формат сообщений.
- Поддержка JSON формата.
- Средний размер сообщения 400 байт на событие.

## Логика работы с событиями.
1. **Flask** принимает JSON:

    - Отслеживание кликов.

          {
             "event": "element_click",
             "token": "srt | null",
             "data": {
                 "element_type": "str" (movie, category, trailer и т.д.),
                 "page_type": "str" (movie, category, promotion и т.д.),
             }
          }

    - Отслеживание просмотров страниц.
    
      Для отслеживания времени проводимого пользователем на страницах, клиент должен генерировать ***"page_view_id"*** и 
      сохранять до момента ухода с просматриваемой страницы, для того что-бы можно было явно отслеживать связанные 
      сообщения о событиях данного типа.

          {
             "event": "str" (page_view_start или page_view_end),
             "token": "srt | null",
             "data": {
                 "page_view_id": "UUID",
                 "page_type": "str" (movie, category, promotion и т.д.),
             }
          }

   - Смена качества видео.
   
         {
             "event": "quality_change",
             "token": "srt | null",
             "data": {
                 "video_id": "str",
                 "old_quality": "int",
                 "new_quality": "int",
             }
         }

   - Просмотр видео до конца.
   
         {
             "event": "video_complete",
             "token": "srt | null",
             "data": {
                 "video_id": "str",
                 "duration_total": "bool",
             }
         }

   - Использование фильтров поиска.
   
         {
             "event": "search_filter",
             "token": "srt | null",
             "data": {
                 "search_query": "str",
                 "filters": "str",
             }
         }

2. Для ненулевого значения ***"token"*** производится проверка токена через **auth_service** с учётом кеша в Redis.
В случаи недоступности сервиса **auth_service** производится локальная проверка токена без учёта его времени жизни.
По результатам проверки, данные обогащаются ключом ***"user_id"*** с ID пользователя или значением *"anonymous"* если 
токен отсутствовал. А ***"token"*** удаляется из сообщения.

3. Данные обогащаются временной меткой ***"timestamp"*** и публикуются в единый топик **Kafka** с ключом, взятым из 
***"event"***.

4. ETL-сервис (по расписанию) читает новые сообщения из **Kafka**.

5. Все сформированные и валидные сообщения **ETL** отправляет в соответствующую значению ***"event"*** таблицу 
**ClickHouse**.